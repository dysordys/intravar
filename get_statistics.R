# This R script reads in the data table containing the simulation
# results. It then calculates the following quantities for each
# simulated community:
# - species richness
# - average community robustness
# - robustness heterogeneity
# - nearest-neighbor coefficient of variation (CV)
# - p-value for whether CV shows significant underdispersion
# Finally, it adds these as new columns to the data, and saves the
# updated table. The script can be run from the command line via
#
# Rscript get_statistics.R [infile] [outfile]
#
# where the command line arguments are:
# - [infile]: the name of the input data file (the one generated by
#             the Mathematica script)
# - [outfile]: name of file to which modified data should be saved


# ---- Function definitions ----


# Obtain number of species that did not go extinct in each simulated community
# Input:
# - tab: the data table
# Output:
# - Srich: vector containing the species richnesses for all simulated communities
SpeciesRichness <- function(tab) {
    Srich <- rep(0, nrow(tab))
    for (i in 1:nrow(tab)) {
        Nvec <- as.numeric(tab[i,(S+6):(2*S+6-1)])
        Srich[i] <- length(Nvec[Nvec>0])
    }
    return(Srich)
}

# Obtain Jacobian of the ecological part of the dynamics
# Input:
# - ns: vector of abundances in final state
# - mus: vector of trait means in final state
# - sigmas: vector of intraspecific standard deviations
# - w: competition width
# - s: list of indices of species whose abundance is positive;
#      the indices refer to the vector ns
# Output:
# - J: the Jacobian matrix
jac <- function(ns, mus, sigmas, w, s) {
    spp <- length(s)
    J <- matrix(0, spp, spp)
    for (i in 1:length(s)) {
        for (j in 1:length(s)) {
            J[i,j] <- (-1)*ns[s[i]]*
                      w*exp(-(mus[s[i]] - mus[s[j]])^2 /
                      (w^2 + 2*sigmas[s[i]]^2 + 2*sigmas[s[j]]^2)) /
                      sqrt(w^2 + 2*sigmas[s[i]]^2 + 2*sigmas[s[j]]^2)
        }
    }
    return(J)
}

# Get Jacobian of one given run, represented by a row of "tab"
# Input:
# - tab: the data table
# - i: the row index, for which the Jacobian should be calculated
# Output:
# - J: the Jacobian matrix
jac_row <- function(tab, i) {
    J <- NA
    row <- as.numeric(tab[i,])
    w <- tab[i,3]
    sigmas <- row[6:(S+6-1)]
    ns <- row[(S+6):(2*S+6-1)]
    mus <- row[(2*S+6):(3*S+6-1)]
    survivors <- which(ns>0)
    J <- jac(ns, mus, sigmas, w, survivors)
    return(J)
}

# Given a Jacobian, obtain the geometric mean / st.dev. of its eigenvalues
# Input:
# - tab: the data table
# - i: the row index, for which the Jacobian should be calculated
# Output: a list with the following entries
# - mew: the geometric mean of the eigenvalues' moduli
# - sew: the geometric std.dev. of the eigenvalues' moduli
robustness <- function(tab, i) {
    J <- jac_row(tab, i)
    eJ <- eigen(J, only.values=TRUE)$values
    mew <- exp(mean(log(abs(eJ))))
    sew <- exp(sd(log(abs(eJ))))
    return(list(mew=mew, sew=sew))
}

# Given a species richness, generate 1000 null CVs
# Input:
# - Ss: richness with which the null CVs should be generated
# Output:
# - dtf: data frame with 1 row and 1001 columns; 1st col: richness,
#        next 1000 cols: null CV values
GenerateNullCVsPerRichness <- function(Ss){
    dtf <- t(sapply(Ss, function(spp) {
        sapply(seq(1000), function(k) {
            nulldists <- rexp(n=spp-1, rate=spp-1)
            sd(nulldists) / mean(nulldists)
        })
    }))
    dtf <- cbind(Ss,dtf)
    colnames(dtf)[1] <- 'S'
    return(data.frame(dtf))	
}

# Obtain CVs in the data communities
# Input:
# - tab: the data table
# Output:
# - cvs: the vector of CVs for each simulated community
IntravarCVs <- function(tab){
    mus <- tab[(2*S+6):(3*S+6-1)]
    Ns <- tab[(S+6):(2*S+6-1)]
    mus[Ns==0] <- NA
    cvs <- apply(mus, 1, function(v) {
        v <- sort(v[is.na(v)==FALSE])
        d <- diff(v)
        return(sd(d)/mean(d))
    })
    return(cvs)
}

# Obtain p-values of the CVs in the data communities
# Input:
# - tab: the data table
# - Srich: vector of species richnesses
# - CVs: vector of CVs
# Output:
# - pval: the vector of p-values for each simulated community
IntravarPvals <- function(tab, Srich, CVs){
    nullCVs <- GenerateNullCVsPerRichness(seq(min(Srich), max(Srich)))
    pval <- sapply(seq(nrow(tab)), function(i) {
        s <- Srich[i]
        cv <- CVs[i]
        ncv <- nullCVs[nullCVs$S==s,-1]
        return(ifelse(s>2, sum(ncv<cv)/length(ncv),NA))
    })
    return(pval)
}


# ---- End of function definitions; beginning of main code ----


arguments <- commandArgs(trailingOnly=TRUE) # Read command line arguments
infile <- arguments[1] # Name of input file, with path and extension
outfile <- arguments[2] # Name of output file, with path and extension

tab <- read.table(infile, header=TRUE) # Load raw data

S <- 51 # Number of initial species; change if needed
richness <- SpeciesRichness(tab) # Obtain final species richness in each row
CV <- IntravarCVs(tab) # Obtain nearest-neighbor CVs
pval <- IntravarPvals(tab, richness, CV) # Obtain p-values (whether CV is
                                         # significantly underdispersed)
gmean <- rep(0, nrow(tab)) # Initialize vector holding the geometric means
                           # of the eigenvalues of the Jacobian for each row
gsd <- rep(0, nrow(tab)) # Same for the geometric standard deviations
for (i in 1:nrow(tab)) { # Calculate them
    rob <- robustness(tab, i)
    gmean[i] <- rob$mew # Geometric mean
    gsd[i] <- rob$sew # Geometric standard deviation
}

# Add new information to existing data as new columns
tab <- cbind(tab, richness)
tab <- cbind(tab, CV)
tab <- cbind(tab, pval)
tab <- cbind(tab, gmean)
tab <- cbind(tab, gsd)

# Save the updated data file
write.table(tab, file=outfile, row.names=FALSE, col.names=TRUE, quote=FALSE)
